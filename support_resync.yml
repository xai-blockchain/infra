---
# XAI Scheduled Resync Playbook
#
# Installs automatic recovery with scheduled state-sync and retry logic.
# Based on Polkachu's support_resync pattern for operational resilience.
#
# Usage:
#   # Install resync script and cron (weekly Sunday 3am)
#   ansible-playbook -i inventory/testnet.yml support_resync.yml --limit xai_node1
#
#   # Custom schedule (daily at 4am)
#   ansible-playbook -i inventory/testnet.yml support_resync.yml --limit xai_node1 \
#     -e resync_hour=4 -e resync_weekday='*'
#
#   # Immediate resync (run now, don't install cron)
#   ansible-playbook -i inventory/testnet.yml support_resync.yml --limit xai_node1 \
#     -e run_now=true -e install_cron=false
#
#   # Install with Slack notifications
#   ansible-playbook -i inventory/testnet.yml support_resync.yml --limit xai_node1 \
#     -e slack_webhook=https://hooks.slack.com/...
#
# Features:
#   - Automatic stall detection (configurable threshold)
#   - State-sync with retry logic
#   - Fallback to snapshot restore
#   - Health verification before/after
#   - Optional Slack/Discord notifications
#   - Detailed logging
#
# References:
#   - https://github.com/polkachu/cosmos-validators (support_resync role)
#   - https://docs.ethstaker.org/scaled-node-operators/key-management-at-scale

- name: XAI Scheduled Resync
  hosts: all
  become: true
  gather_facts: true

  vars:
    # Resync schedule (cron format)
    resync_hour: 3
    resync_minute: 0
    resync_weekday: 0  # Sunday (0-6, Sunday=0)

    # Install cron job
    install_cron: true

    # Run resync immediately
    run_now: false

    # Stall detection threshold (blocks behind)
    stall_threshold: 100

    # Health check settings
    health_check_retries: 30
    health_check_delay: 10

    # State sync settings
    state_sync_retries: 3
    state_sync_rpc: "{{ state_sync_rpc_servers | default(['http://127.0.0.1:12570', 'http://127.0.0.1:12571']) }}"

    # Snapshot fallback
    snapshot_enabled: true
    snapshot_url: "https://artifacts.xaiblockchain.com/{{ chain_id | default('xai-mvp-testnet-1') }}/snapshots/latest.json"

    # Script locations
    resync_script_path: "/usr/local/bin/xai-resync-{{ node_name }}.sh"
    resync_log_path: "/var/log/xai/resync-{{ node_name }}.log"

  tasks:
    # =========================================================================
    # Pre-flight Checks
    # =========================================================================
    - name: Verify required variables
      ansible.builtin.assert:
        that:
          - node_name is defined
          - daemon_home is defined
          - service_name is defined
          - rpc_port is defined
        fail_msg: "Required variables: node_name, daemon_home, service_name, rpc_port"

    - name: Create log directory
      ansible.builtin.file:
        path: /var/log/xai
        state: directory
        owner: "{{ daemon_user }}"
        group: "{{ daemon_user }}"
        mode: '0755'

    # =========================================================================
    # Deploy Resync Script
    # =========================================================================
    - name: Deploy resync script
      ansible.builtin.copy:
        content: |
          #!/bin/bash
          # XAI Automatic Resync Script for {{ node_name }}
          # Generated by Ansible - DO NOT EDIT MANUALLY
          #
          # This script:
          # 1. Checks if node is stalled (behind by {{ stall_threshold }}+ blocks)
          # 2. Attempts state-sync recovery
          # 3. Falls back to snapshot restore if state-sync fails
          # 4. Verifies node health after recovery

          set -euo pipefail

          # Configuration
          NODE_NAME="{{ node_name }}"
          SERVICE_NAME="{{ service_name }}"
          DAEMON_HOME="{{ daemon_home }}"
          RPC_PORT="{{ rpc_port }}"
          STALL_THRESHOLD="{{ stall_threshold }}"
          LOG_FILE="{{ resync_log_path }}"
          SLACK_WEBHOOK="${SLACK_WEBHOOK:-{{ slack_webhook | default('') }}}"
          DISCORD_WEBHOOK="${DISCORD_WEBHOOK:-{{ discord_webhook | default('') }}}"

          # State sync RPCs
          STATE_SYNC_RPCS=({% for rpc in state_sync_rpc %}"{{ rpc }}" {% endfor %})

          # Snapshot settings
          SNAPSHOT_ENABLED="{{ snapshot_enabled | lower }}"
          SNAPSHOT_URL="{{ snapshot_url }}"

          # Logging
          log() {
              echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
          }

          notify() {
              local message="$1"
              local level="${2:-info}"

              log "[$level] $message"

              if [[ -n "$SLACK_WEBHOOK" ]]; then
                  curl -s -X POST -H 'Content-type: application/json' \
                      --data "{\"text\":\"[$level] XAI $NODE_NAME: $message\"}" \
                      "$SLACK_WEBHOOK" > /dev/null || true
              fi

              if [[ -n "$DISCORD_WEBHOOK" ]]; then
                  curl -s -X POST -H 'Content-type: application/json' \
                      --data "{\"content\":\"[$level] XAI $NODE_NAME: $message\"}" \
                      "$DISCORD_WEBHOOK" > /dev/null || true
              fi
          }

          # Get current block height
          get_local_height() {
              curl -s --max-time 10 "http://127.0.0.1:$RPC_PORT/stats" 2>/dev/null | \
                  jq -r '.chain_height // 0' 2>/dev/null || echo "0"
          }

          # Get network height from state sync RPCs
          get_network_height() {
              for rpc in "${STATE_SYNC_RPCS[@]}"; do
                  height=$(curl -s --max-time 10 "$rpc/stats" 2>/dev/null | \
                      jq -r '.chain_height // 0' 2>/dev/null || echo "0")
                  if [[ "$height" -gt 0 ]]; then
                      echo "$height"
                      return
                  fi
              done
              echo "0"
          }

          # Check if node is stalled
          is_stalled() {
              local local_height=$(get_local_height)
              local network_height=$(get_network_height)

              if [[ "$network_height" -eq 0 ]]; then
                  log "WARNING: Could not get network height, assuming not stalled"
                  return 1
              fi

              local behind=$((network_height - local_height))
              log "Local height: $local_height, Network height: $network_height, Behind: $behind blocks"

              if [[ "$behind" -gt "$STALL_THRESHOLD" ]]; then
                  return 0  # Stalled
              fi
              return 1  # Not stalled
          }

          # Wait for node to be healthy
          wait_for_health() {
              local retries=${1:-30}
              local delay=${2:-10}

              for ((i=1; i<=retries; i++)); do
                  if curl -s --max-time 5 "http://127.0.0.1:$RPC_PORT/stats" > /dev/null 2>&1; then
                      log "Node is responding (attempt $i/$retries)"
                      return 0
                  fi
                  log "Waiting for node to respond (attempt $i/$retries)..."
                  sleep "$delay"
              done
              return 1
          }

          # Perform state sync
          do_state_sync() {
              log "Attempting state sync recovery..."

              # Stop node
              systemctl stop "$SERVICE_NAME" || true
              sleep 5

              # Clear state data but keep identity
              if [[ -d "$DAEMON_HOME/data/blocks" ]]; then
                  log "Backing up and clearing state data..."
                  mv "$DAEMON_HOME/data" "$DAEMON_HOME/data.backup.$(date +%s)" || true
                  mkdir -p "$DAEMON_HOME/data"

                  # Restore identity if it was backed up
                  if [[ -f "$DAEMON_HOME/data.backup."*/node_identity.json ]]; then
                      cp "$DAEMON_HOME/data.backup."*/node_identity.json "$DAEMON_HOME/data/" 2>/dev/null || true
                  fi
              fi

              # Start node (it will state sync automatically with peers)
              systemctl start "$SERVICE_NAME"

              # Wait for node to sync
              log "Waiting for node to sync..."
              sleep 30

              if wait_for_health {{ health_check_retries }} {{ health_check_delay }}; then
                  local new_height=$(get_local_height)
                  if [[ "$new_height" -gt 0 ]]; then
                      log "State sync successful! New height: $new_height"
                      return 0
                  fi
              fi

              log "State sync failed"
              return 1
          }

          # Perform snapshot restore
          do_snapshot_restore() {
              if [[ "$SNAPSHOT_ENABLED" != "true" ]]; then
                  log "Snapshot restore disabled"
                  return 1
              fi

              log "Attempting snapshot restore..."

              # Get latest snapshot URL
              local snapshot_info=$(curl -s --max-time 30 "$SNAPSHOT_URL" 2>/dev/null)
              local snapshot_download=$(echo "$snapshot_info" | jq -r '.url // empty' 2>/dev/null)

              if [[ -z "$snapshot_download" ]]; then
                  log "Could not get snapshot URL"
                  return 1
              fi

              log "Downloading snapshot from: $snapshot_download"

              # Stop node
              systemctl stop "$SERVICE_NAME" || true
              sleep 5

              # Backup and clear data
              if [[ -d "$DAEMON_HOME/data" ]]; then
                  mv "$DAEMON_HOME/data" "$DAEMON_HOME/data.snapshot-backup.$(date +%s)" || true
              fi
              mkdir -p "$DAEMON_HOME/data"

              # Download and extract snapshot
              cd /tmp
              if curl -L --max-time 600 -o snapshot.tar.lz4 "$snapshot_download"; then
                  lz4 -d snapshot.tar.lz4 | tar -xf - -C "$DAEMON_HOME/data"
                  rm -f snapshot.tar.lz4

                  # Restore identity
                  if [[ -f "$DAEMON_HOME/data.snapshot-backup."*/node_identity.json ]]; then
                      cp "$DAEMON_HOME/data.snapshot-backup."*/node_identity.json "$DAEMON_HOME/data/" 2>/dev/null || true
                  fi

                  # Fix permissions
                  chown -R {{ daemon_user }}:{{ daemon_user }} "$DAEMON_HOME/data"

                  # Start node
                  systemctl start "$SERVICE_NAME"

                  if wait_for_health {{ health_check_retries }} {{ health_check_delay }}; then
                      local new_height=$(get_local_height)
                      log "Snapshot restore successful! Height: $new_height"
                      return 0
                  fi
              fi

              log "Snapshot restore failed"
              return 1
          }

          # Clean up old backups
          cleanup_backups() {
              log "Cleaning up old backups..."
              # Keep last 2 backups
              ls -dt "$DAEMON_HOME"/data.backup.* 2>/dev/null | tail -n +3 | xargs -r rm -rf || true
              ls -dt "$DAEMON_HOME"/data.snapshot-backup.* 2>/dev/null | tail -n +3 | xargs -r rm -rf || true
          }

          # Main
          main() {
              log "=========================================="
              log "XAI Resync Check Starting for $NODE_NAME"
              log "=========================================="

              # Check if node is stalled
              if ! is_stalled; then
                  log "Node is healthy, no resync needed"
                  cleanup_backups
                  exit 0
              fi

              notify "Node appears stalled, initiating recovery" "warning"

              # Try state sync first
              for attempt in 1 2 3; do
                  log "State sync attempt $attempt/3..."
                  if do_state_sync; then
                      notify "Recovery successful via state sync" "info"
                      cleanup_backups
                      exit 0
                  fi
                  sleep 30
              done

              # Fall back to snapshot
              log "State sync failed, trying snapshot restore..."
              if do_snapshot_restore; then
                  notify "Recovery successful via snapshot restore" "info"
                  cleanup_backups
                  exit 0
              fi

              # All recovery methods failed
              notify "All recovery methods failed! Manual intervention required" "error"
              exit 1
          }

          main "$@"
        dest: "{{ resync_script_path }}"
        owner: root
        group: root
        mode: '0755'

    # =========================================================================
    # Install Cron Job
    # =========================================================================
    - name: Install resync cron job
      ansible.builtin.cron:
        name: "XAI resync {{ node_name }}"
        minute: "{{ resync_minute }}"
        hour: "{{ resync_hour }}"
        weekday: "{{ resync_weekday }}"
        job: "{{ resync_script_path }} >> {{ resync_log_path }} 2>&1"
        user: root
      when: install_cron | bool

    - name: Display cron schedule
      ansible.builtin.debug:
        msg: |
          Resync cron installed:
            Schedule: {{ resync_minute }} {{ resync_hour }} * * {{ resync_weekday }}
            Script: {{ resync_script_path }}
            Log: {{ resync_log_path }}
      when: install_cron | bool

    # =========================================================================
    # Logrotate Configuration
    # =========================================================================
    - name: Configure logrotate for resync logs
      ansible.builtin.copy:
        content: |
          {{ resync_log_path }} {
              daily
              rotate 14
              compress
              delaycompress
              missingok
              notifempty
              create 0640 {{ daemon_user }} {{ daemon_user }}
          }
        dest: "/etc/logrotate.d/xai-resync-{{ node_name }}"
        mode: '0644'

    # =========================================================================
    # Run Immediately (if requested)
    # =========================================================================
    - name: Run resync now
      ansible.builtin.command:
        cmd: "{{ resync_script_path }}"
      register: resync_result
      when: run_now | bool
      changed_when: true
      failed_when: false

    - name: Display resync output
      ansible.builtin.debug:
        msg: "{{ resync_result.stdout_lines | default(['No output']) }}"
      when: run_now | bool

    # =========================================================================
    # Summary
    # =========================================================================
    - name: Display summary
      ansible.builtin.debug:
        msg: |
          ╔══════════════════════════════════════════════════════════════════╗
          ║                   XAI RESYNC SETUP COMPLETE                      ║
          ╠══════════════════════════════════════════════════════════════════╣
          ║ Node: {{ node_name }}
          ║ Script: {{ resync_script_path }}
          ║ Log: {{ resync_log_path }}
          ║ Cron: {{ 'INSTALLED (min:' ~ resync_minute ~ ' hour:' ~ resync_hour ~ ' weekday:' ~ resync_weekday ~ ')' if install_cron else 'NOT INSTALLED' }}
          ║ Stall threshold: {{ stall_threshold }} blocks
          ║ Snapshot fallback: {{ 'ENABLED' if snapshot_enabled else 'DISABLED' }}
          ╠══════════════════════════════════════════════════════════════════╣
          ║ MANUAL COMMANDS:                                                 ║
          ║ • Run now: {{ resync_script_path }}
          ║ • View logs: tail -f {{ resync_log_path }}
          ║ • Check cron: crontab -l | grep resync                           ║
          ╚══════════════════════════════════════════════════════════════════╝
